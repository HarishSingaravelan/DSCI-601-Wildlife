import os
import json
import xml.etree.ElementTree as ET
from PIL import Image
from typing import Dict, List, Any, Optional

ROOT_DIR = "Sample_images"
OUTPUT_JSON = "coco_annotations.json"

# Define extensions to check for. Order matters: it will check for .json first, then .xml.
ANNOTATION_EXTENSIONS = ['.json', '.xml']
IMAGE_EXTENSIONS = ('.jpg', '.jpeg', '.png', '.tiff')


CATEGORY_MAPPING = {
    "red_winged_blackbird": 1,
    "mammal_carcass": 2,
    "hawk_species": 3,
    "gull_species": 4,
    "trash": 5, # Often included to train the model to ignore non-animal objects
}

# --- COCO Metadata Structure (Automatically generated from mapping) ---
COCO_INFO = {
    "year": 2024,
    "version": "1.0",
    "description": "UAS Wildlife Detection Dataset (Generated by Script)",
    "contributor": "AI Assistant",
    "date_created": "2025-09-30"
}

COCO_LICENSES = [
    {
        "id": 1,
        "name": "Unknown / Custom License",
        "url": ""
    }
]

COCO_CATEGORIES = [
    {"id": cat_id, "name": cat_name, "supercategory": "wildlife"}
    for cat_name, cat_id in CATEGORY_MAPPING.items()
]

# --- Helper Functions ---

def get_image_dimensions(image_path: str) -> Optional[tuple]:
    """Retrieves image width and height using PIL without loading full data."""
    try:
        with Image.open(image_path) as img:
            return img.width, img.height
    except Exception as e:
        print(f"Warning: Could not read dimensions for {image_path}: {e}")
        return None

def parse_custom_json(json_path: str, image_id: int, image_width: int, image_height: int, annotation_id_counter: int) -> tuple:
    """
    Parses a custom JSON file (normalized coordinates) to extract bounding box annotations
    in COCO format (xmin, ymin, width, height).
    """
    annotations = []
    try:
        with open(json_path, 'r') as f:
            data = json.load(f)
    except Exception as e:
        print(f"Warning: Could not parse JSON file {json_path}: {e}")
        return annotations, annotation_id_counter

    for carcass in data.get('carcasses', []):
        class_name = carcass.get('class')
        
        # Skip if the class name is not mapped or missing
        if not class_name or class_name not in CATEGORY_MAPPING:
            # print(f"Warning: Skipping unknown or missing category in {json_path}") # Uncomment for debugging
            continue

        category_id = CATEGORY_MAPPING[class_name]
        locations = carcass.get('location', [])
        
        if len(locations) < 2:
            print(f"Warning: Skipping annotation with insufficient location data in {json_path}")
            continue

        # Extract and convert normalized coordinates (assuming two corners)
        try:
            nx1 = float(locations[0]['x'])
            ny1 = float(locations[0]['y'])
            nx2 = float(locations[1]['x'])
            ny2 = float(locations[1]['y'])
        except (ValueError, TypeError, KeyError) as e:
            print(f"Warning: Invalid coordinate format in {json_path}: {e}")
            continue

        # Determine min/max normalized coordinates
        n_xmin = min(nx1, nx2)
        n_ymin = min(ny1, ny2)
        n_xmax = max(nx1, nx2)
        n_ymax = max(ny1, ny2)

        # Convert to absolute pixel coordinates
        xmin = int(n_xmin * image_width)
        ymin = int(n_ymin * image_height)
        xmax = int(n_xmax * image_width)
        ymax = int(n_ymax * image_height)

        # Ensure valid dimensions
        width = max(0, xmax - xmin)
        height = max(0, ymax - ymin)
        area = width * height

        if width == 0 or height == 0:
            print(f"Warning: Annotation results in zero area box in {json_path}. Skipping.")
            continue

        # Create COCO annotation entry
        annotation = {
            "id": annotation_id_counter,
            "image_id": image_id,
            "category_id": category_id,
            "iscrowd": 0,
            "bbox": [xmin, ymin, width, height],
            "area": area,
            "segmentation": [[
                xmin, ymin, xmax, ymin, xmax, ymax, xmin, ymax # Simple rectangular segmentation
            ]],
        }
        annotations.append(annotation)
        annotation_id_counter += 1

    return annotations, annotation_id_counter


def parse_pascal_voc_xml(xml_path: str, image_id: int, annotation_id_counter: int) -> tuple:
    """
    Parses a Pascal VOC XML file (absolute coordinates) to extract bounding box annotations
    in COCO format (xmin, ymin, width, height).
    """
    annotations = []
    try:
        tree = ET.parse(xml_path)
        root = tree.getroot()
    except Exception as e:
        print(f"Warning: Could not parse XML file {xml_path}: {e}")
        return annotations, annotation_id_counter

    for obj in root.findall('object'):
        class_name = obj.find('name').text
        
        # Skip if the class name is not mapped
        if class_name not in CATEGORY_MAPPING:
            print(f"Warning: Skipping unknown category '{class_name}' in {xml_path}")
            continue

        category_id = CATEGORY_MAPPING[class_name]
        
        # Bounding box coordinates (absolute pixels)
        bndbox = obj.find('bndbox')
        xmin = int(float(bndbox.find('xmin').text))
        ymin = int(float(bndbox.find('ymin').text))
        xmax = int(float(bndbox.find('xmax').text))
        ymax = int(float(bndbox.find('ymax').text))

        # Convert to COCO format: [x_min, y_min, width, height]
        width = max(0, xmax - xmin)
        height = max(0, ymax - ymin)
        area = width * height

        if width == 0 or height == 0:
            print(f"Warning: Annotation results in zero area box in {xml_path}. Skipping.")
            continue


        # Create COCO annotation entry
        annotation = {
            "id": annotation_id_counter,
            "image_id": image_id,
            "category_id": category_id,
            "iscrowd": 0,
            "bbox": [xmin, ymin, width, height],
            "area": area,
            "segmentation": [[
                xmin, ymin, xmax, ymin, xmax, ymax, xmin, ymax # Simple rectangular segmentation
            ]],
        }
        annotations.append(annotation)
        annotation_id_counter += 1

    return annotations, annotation_id_counter

def generate_coco_json(root_dir: str, output_path: str):
    """
    Scans the directory structure, collects data, and generates the COCO JSON.
    """
    coco_dataset = {
        "info": COCO_INFO,
        "licenses": COCO_LICENSES,
        # IMPORTANT: COCO_CATEGORIES now reflects all entries in CATEGORY_MAPPING
        "categories": COCO_CATEGORIES, 
        "images": [],
        "annotations": []
    }

    image_id_counter = 1
    annotation_id_counter = 1

    # Extract the name of the root directory for inclusion in the path
    root_dir_name = os.path.basename(os.path.normpath(root_dir))

    print(f"Starting scan in: {root_dir}")
    print(f"Prepending root directory name: {root_dir_name}")
    print("-" * 30)

    for root, _, files in os.walk(root_dir):
        for file_name in files:
            if file_name.lower().endswith(IMAGE_EXTENSIONS):
                image_full_path = os.path.join(root, file_name)
                
                # --- MODIFICATION START ---
                # 1. Get path relative to the root directory
                path_relative_to_root = os.path.relpath(image_full_path, root_dir)
                
                # 2. Prepend the root directory name and normalize separators
                image_relative_path = os.path.join(root_dir_name, path_relative_to_root).replace(os.path.sep, '/')
                # --- MODIFICATION END ---
                
                # Get dimensions
                dims = get_image_dimensions(image_full_path)
                if not dims:
                    continue
                width, height = dims
                
                # --- 1. Add Image Entry ---
                image_entry = {
                    "id": image_id_counter,
                    "width": width,
                    "height": height,
                    "file_name": image_relative_path,
                    "license": 1 
                }
                coco_dataset["images"].append(image_entry)
                
                # --- 2. Find and Parse Annotation File (Check JSON first, then XML) ---
                base_name, _ = os.path.splitext(file_name)
                
                found_annotation = False
                new_annotations = []
                
                for ext in ANNOTATION_EXTENSIONS:
                    annotation_path = os.path.join(root, base_name + ext)
                    
                    if os.path.exists(annotation_path):
                        found_annotation = True
                        
                        if ext == '.json':
                            new_annotations, annotation_id_counter = parse_custom_json(
                                annotation_path, image_id_counter, width, height, annotation_id_counter
                            )
                            # print(f"Found and parsed JSON annotations ({len(new_annotations)}) for {image_relative_path}")
                        
                        elif ext == '.xml':
                            new_annotations, annotation_id_counter = parse_pascal_voc_xml(
                                annotation_path, image_id_counter, annotation_id_counter
                            )
                            # print(f"Found and parsed XML annotations ({len(new_annotations)}) for {image_relative_path}")
                        
                        coco_dataset["annotations"].extend(new_annotations)
                        break # Stop checking for other formats once one is found

                if not found_annotation:
                    # print(f"Found image: {image_relative_path} (No annotations found)") # Uncomment for debugging
                    pass
                
                image_id_counter += 1

    # --- 3. Write Output JSON ---
    print("-" * 30)
    print(f"Scan complete. Total categories included: {len(COCO_CATEGORIES)}")
    print(f"Total images found: {image_id_counter - 1}")
    print(f"Total annotations collected: {len(coco_dataset['annotations'])}")

    try:
        with open(output_path, 'w') as f:
            json.dump(coco_dataset, f, indent=4)
        print(f"Successfully generated COCO JSON file at: {output_path}")
    except Exception as e:
        print(f"Error writing JSON file: {e}")

# --- Execution ---
if __name__ == '__main__':
    generate_coco_json(ROOT_DIR, OUTPUT_JSON)